# pchGenerator

import sys
import subprocess

from stack import Stack
from headers_dag import HeaderNode, HeadersDag
from topological_sorter import TopologicalSorter
from recursive_filter import RecursiveFilter
from processArgv import processArgv

#
# parseLine
#
def parseLine( line ):
    i = 0
    length = len( line )

    while i < length and line[i] == '.':
        i += 1

    if i == 0:
        raise Exception( "Wrong line format: 'filename'" )

    if line[i] != ' ':
        raise Exception( "Wrong line format: '...filename'" )

    if i + 1 == length:
        raise Exception( "Wrong line format: '... '" )

    return ( i, line[ i + 1 : len(line) ] )

#
# ShouldBeInPCH
#
class ShouldBeInPCH:
    def __init__( self, options ):
        self._options = options
        
        self._options.threshold = self.__calculateThreshold( options )

    def __call__( self, node ):
        isFileTypeOK = self.__isFirstLevelNonApplicationHeader( node )
        isThresholdOK = self.__checkThreshold( node, self._options )
        isExclusionOK = self.__checkExclusion( node, self._options )
        
        return isFileTypeOK and isThresholdOK and isExclusionOK

    def __calculateThreshold( self, options ):
        threshold = options.threshold[0]
        numberOfFiles = len( options.files )
        
        return max( 1, numberOfFiles * threshold ) / 100
        
    def __isFirstLevelNonApplicationHeader( self, node ):
        if self.__isApplicationHeader( node ) == True:
            return False

        for parent in node.getParents():
            if parent.isRoot():
                return True

            if self.__isApplicationHeader( parent ):
                return True

        return False

    def __isApplicationHeader( self, node ):
        return node.getData().startswith( "path/to/my/project" )

    def __checkThreshold( self, node, options ):
        return node.getCounter() >= options.threshold
        
    def __checkExclusion( self, node, options ):
        if self.__findAnyOf( node.getData(), options.exclude_except ):
            return True
        
        if self.__findAnyOf( node.getData(), options.exclude ):
            return False
        
        return True
        
    def __findAnyOf( self, value, patterns ):
        for pattern in patterns:
            if value.find( pattern ) != -1:
                return True
            
        return False
#
# generateHeadersDag
#
def generateHeadersDag( options ):
    dag = HeadersDag()

    for sourceFilename in options.files:
        output = subprocess.check_output(
            ["g++.exe", "-H", sourceFilename],
            stderr=subprocess.STDOUT,
            universal_newlines=True
        )

        for line in output.split( "\n" ):
            if len( line ) == 0:
                continue

            depth, filename = parseLine( line )
            dag.add( depth, filename )

        dag.processOneFile()

    return dag

#
# generatePCHPrologue
#
def generatePCHPrologue( options ):
    print( "// File generated by :", sys.argv[0] )
    print( "// Compilation options:", options.compilation_options )
    print( "// Threshold          :", options.threshold )
    print( "// Exclude pattern    :", options.exclude )
    print( "// Exclude but pattern:", options.exclude_except )
#
# generatePCH
#
def generatePCH( rFilter, options ):
    generatePCHPrologue( options )

    for node in rFilter.getNodes():
        print( node.getData() )

#
# runApplication
#
def runApplication():
    options = processArgv()

    dag = generateHeadersDag( options )

    tSorter = TopologicalSorter( dag )

    predicate = ShouldBeInPCH( options )

    rFilter = RecursiveFilter( tSorter, predicate )

    generatePCH( rFilter, options )

#
# main
#
if __name__ == "__main__":
    runApplication()
